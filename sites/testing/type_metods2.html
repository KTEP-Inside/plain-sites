<!DOCTYPE html>
<html class="no-js" lang="en"> 
<head>

   <meta charset="utf-8">
	<title>Тестирование программного обеспечения</title>
	<meta name="description" content="">
	<meta name="author" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="css/default.css">
	<link rel="stylesheet" href="css/layout.css">
    <link rel="stylesheet" href="css/media-queries.css">
	<script src="js/modernizr.js"></script>
	<link rel="shortcut icon" href="favicon.ico" >

</head>

<body>
   <header>

      <div class="row">

         <div class="twelve columns">


            <nav id="nav-wrap">
               <a class="mobile-btn" href="#nav-wrap" title="Показать разделы">Показать разделы</a>
	            <a class="mobile-btn" href="#" title="Скрыть разделы">Скрыть разделы</a>
               <ul id="nav" class="nav">


	               <li><a href="index.html">Главная</a></li>
	               <li><a href="osnovnoe.html">Основные понятия</a></li>
                   <li class="current"><span><a>Типы ошибок и методы отладки</a></span>
						<ul>
							<li><a href="type_metods.html">Типы ошибок</a></li>
							<li><a href="type_metods2.html">Отладка и тестирование программ</a></li>
						</ul>
                   </li>
	               <li><span><a>Процессы тестирования и разработки ПО</a></span>
						<ul>
							<li><a href="proc.html">Модели разработки ПО</a></li>
							<li><a href="proc2.html">Жизненный цикл тестирования</a></li>
						</ul>
	               </li>
	               <li><span><a>Классификация тестирования</a></span>
						<ul>
							<li><a href="upr.html">Метод белого ящика</a></li>
							<li><a href="upr2.html">Метод чёрного ящика</a></li>
							<li><a href="upr3.html">Ручное тестирование</a></li>
							<li><a href="upr4.html">Автоматизированное тестирование</a></li>
							<li><a href="upr5.html">Модульное (компонентное) тестирование</a></li>
							<li><a href="upr6.html">Интеграционное тестирование</a></li>
						</ul>
	               </li>
                   <li><span><a>Тест-кейс</a></span>
						<ul>
							<li><a href="test.html">Описание</a></li>
							<li><a href="test2.html">Практическая работа № 1</a></li>
							<li><a href="test3.html">Практическая работа № 2</a></li>
						</ul>
                   </li>
               </ul> <!-- end #nav -->

            </nav> <!-- end #nav-wrap -->

         </div>

      </div>

   </header> <!-- Header End -->

   <!-- Page Title
   ================================================== -->
   <div id="page-title">

      <div class="row">

         <div class="ten columns centered text-center">
            <h1>Тестирование программного обеспечения</h1>
         </div>

      </div>

   </div> <!-- Page Title End-->

   <!-- Content
   ================================================== -->
   <div class="content-outer">

      <div id="page-content">

         <div class="row add-bottom">

            <div class="twelve columns" style="padding-top: 24px;">

               <h1 class="title-heading">Отладка и тестирование программ</h1><br/>

               <p class="lead add-bottom">1. <b>Отладка программы</b></p>
               <p class="lead add-bottom">Отладка - это процесс локализации и исправления ошибок в программе. Бывает двух видов:</p>
               <p class="lead add-bottom">- синтаксическая отладка. Синтаксические ошибки выявляет компилятор, поэтому исправлять их достаточно легко;</p>
               <p class="lead add-bottom">- семантическая (смысловая) отладка. Ее время наступает тогда, когда синтаксических ошибок не осталось, но результаты программа выдает неверные. Здесь компилятор сам ничего выявить не сможет, хотя в среде программирования обычно существуют вспомогательные средства отладки, о которых мы еще поговорим.</p>
               <p class="lead add-bottom">2. <b>Локализация ошибок</b></p>
               <p class="lead add-bottom">Локализация - это нахождение места ошибки в программе.</p>
               <p class="lead add-bottom">В процессе поиска ошибки обычно выполняют одни и те же действия: </p>
               <p class="lead add-bottom">- прогоняют программу и получают результаты;</p>
               <p class="lead add-bottom">- сверяют результаты с эталонными и анализируют несоответствие;</p>
               <p class="lead add-bottom">- выявляют наличие ошибки, выдвигают гипотезу о ее характере и месте в программе;</p>
               <p class="lead add-bottom">- проверяют текст программы, исправляют ошибку, если нашли ее правильно.</p>
               <p class="lead add-bottom"><b>Способы обнаружения ошибки:</b></p>
               <p class="lead add-bottom">Аналитический - имея достаточное представление о структуре программы, просматривают ее текст вручную, без прогона.</p>
               <p class="lead add-bottom">Экспериментальный - прогоняют программу, используя отладочную печать и средства трассировки, и анализируют результаты ее работы.</p>
               <p class="lead add-bottom">Оба способа по-своему удобны и обычно используются совместно.</p>
               <p class="lead add-bottom">3. <b>Принципы отладки. Принципы локализации ошибок</b></p>
               <p class="lead add-bottom">Большинство ошибок обнаруживается вообще без запуска программы - просто внимательным просматриванием текста.</p>
               <p class="lead add-bottom">Если отладка зашла в тупик и обнаружить ошибку не удается, лучше отложить программу. Когда глаз "замылен", эффективность работы упорно стремится к нулю.</p>
               <p class="lead add-bottom">Чрезвычайно удобные вспомогательные средства - это отладочные механизмы среды разработки: трассировка, промежуточный контроль значений. Можно использовать даже дамп памяти, но такие радикальные действия нужны крайне редко.</p>
               <p class="lead add-bottom">Экспериментирования типа "а что будет, если изменить плюс на минус" - нужно избегать всеми силами. Обычно это не дает результатов, а только больше запутывает процесс отладки, да еще и добавляет новые ошибки.</p>
               <p class="lead add-bottom"><b>Принципы исправления ошибок:</b></p>
               <p class="lead add-bottom">Там, где найдена одна ошибка, возможно, есть и другие.</p>
               <p class="lead add-bottom">Вероятность, что ошибка найдена правильно, никогда не равна ста процентам.</p>
               <p class="lead add-bottom">Наша задача - найти саму ошибку, а не ее симптом.</p>
               <p class="lead add-bottom">Это утверждение хочется пояснить. Если программа упорно выдает результат 0,1 вместо эталонного нуля, простым округлением вопрос не решить. Если результат получается отрицательным вместо эталонного положительного, бесполезно брать его по модулю - получим вместо решения задачи ерунду с подгонкой.</p>
               <p class="lead add-bottom">Исправляя одну ошибку, очень легко внести в программу еще парочку. "Наведенные" ошибки - настоящий бич отладки.</p>
               <p class="lead add-bottom">Исправление ошибок зачастую вынуждает возвращаться на этап составления программы.</p>
               <p class="lead add-bottom">4. <b>Методы отладки. Силовые методы</b></p>
               <p class="lead add-bottom">- Использование дампа (распечатки) памяти.</p>
               <p class="lead add-bottom">Это интересно с познавательной точки зрения: можно досконально разобраться в машинных процессах. Иногда такой подход даже необходим - например, когда речь идет о выделении и высвобождении памяти под динамические переменные с использованием недокументированных возможностей языка. Однако, в большинстве случаев получают огромное количество низкоуровневой информации.</p>
               <p class="lead add-bottom">- Использование отладочной печати в тексте программы - произвольно и в большом количестве.</p>
               <p class="lead add-bottom">Получать информацию о выполнении каждого оператора тоже небезынтересно. Но здесь снова сталкиваемся со слишком большими объемами информации. Кроме того, программа захламляется добавочными операторами, получая малочитабельный текст и риск внести десяток новых ошибок.</p>
               <p class="lead add-bottom">- Использование автоматических средств отладки - трассировки с отслеживанием промежуточных значений переменных.</p>
               <p class="lead add-bottom">Это самый распространенный способ отладки. Не нужно только забывать, что это только один из способов, и применять всегда и везде только его - часто невыгодно.</p>
               <p class="lead add-bottom">Сложности возникают, когда приходится отслеживать слишком большие структуры данных или огромное их число. Еще проблематичнее трассировать проект, где выполнение каждой подпрограммы приводит к вызову пары десятков других. Но для небольших программ трассировки вполне достаточно.</p>
               <p class="lead add-bottom">С точки зрения "правильного" программирования силовые методы плохи тем, что не поощряют анализ задачи.</p>
               <p class="lead add-bottom">Суммируя свойства силовых методов, получаем <b>практические советы</b>:</p>
               <p class="lead add-bottom">- использовать трассировку и отслеживание значений переменных для небольших проектов, отдельных подпрограмм;</p>
               <p class="lead add-bottom">- использовать отладочную печать в небольших количества и "по делу";</p>
               <p class="lead add-bottom">- оставить дамп памяти на самый крайний случай.</p>
               <p class="lead add-bottom"><b>Метод индукции</b> - анализ программы от частного к общему.</p>
               <p class="lead add-bottom">Просматриваем симптомы ошибки и определяем данные, которые имеют к ней хоть какое-то отношение. Затем, используя тесты, исключаем маловероятные гипотезы, пока не остается одна, которую пытаемся уточнить и доказать.</p>
               <p class="lead add-bottom"><b>Метод дедукции</b> - от общего к частному.</p>
               <p class="lead add-bottom">Выдвигаем гипотезу, которая может объяснить ошибку, пусть и не полностью. Затем при помощи тестов эта гипотеза проверяется и доказывается.</p>
               <p class="lead add-bottom"><b>Обратное движение по алгоритму</b></p>
               <p class="lead add-bottom">Отладка начинается там, где впервые встретился неправильный результат. Затем работа программы прослеживается (мысленно или при помощи тестов) в обратном порядке, пока не будет обнаружено место возможной ошибки.</p>
            <hr>

            </div>

         </div> <!-- Row End-->


      </div> <!-- page-content End-->

   </div> <!-- Content End-->

   <!-- footer
   ================================================== -->
   <footer>

      <div class="row">

         <div class="twelve columns">
            <ul class="copyright">
               <li>Калужский техникум электронных приборов 2021</a></li>               
            </ul>

         </div>

         <div id="go-top" style="display: block;"><a title="Back to Top" href="#">Go To Top</a></div>

      </div>

   </footer> 

   <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
   <script>window.jQuery || document.write('<script src="js/jquery-1.10.2.min.js"><\/script>')</script>
   <script type="text/javascript" src="js/jquery-migrate-1.2.1.min.js"></script>

   <script src="js/jquery.flexslider.js"></script>
   <script src="js/doubletaptogo.js"></script>
   <script src="js/init.js"></script>

</body>

</html>
